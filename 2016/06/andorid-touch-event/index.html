<!DOCTYPE html>
<html lang="zh-CN">
<head>

  <meta charset="utf-8" />

  
  <title>事件分发过程</title>

  
  
  <link href="//cdn.jsdelivr.net" rel="dns-prefetch">
  <link href="//cdnjs.cloudflare.com" rel="dns-prefetch">
  <link href="//at.alicdn.com" rel="dns-prefetch">
  <link href="//fonts.googleapis.com" rel="dns-prefetch">
  <link href="//fonts.gstatic.com" rel="dns-prefetch">
  
  
  
  
  

  

  
  
  <meta name="description" content="这篇文章我们继续分析Activity的事件分发过程。
">

  
  
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@gohugoio">
    <meta name="twitter:title" content="事件分发过程">
    <meta name="twitter:description" content="这篇文章我们继续分析Activity的事件分发过程。
">
    <meta name="twitter:image" content="/hadyang.github.io/images/avatar.png">
  

  
  <meta property="og:type" content="article">
  <meta property="og:title" content="事件分发过程">
  <meta property="og:description" content="这篇文章我们继续分析Activity的事件分发过程。
">
  <meta property="og:url" content="hadyang.github.io/2016/06/andorid-touch-event/">
  <meta property="og:image" content="/hadyang.github.io/images/avatar.png">




<meta name="generator" content="Hugo 0.54.0">


<link rel="canonical" href="hadyang.github.io/2016/06/andorid-touch-event/">

<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="format-detection" content="telephone=no,email=no,adress=no">
<meta http-equiv="Cache-Control" content="no-transform">


<meta name="robots" content="index,follow">
<meta name="referrer" content="origin-when-cross-origin">







<meta name="theme-color" content="#02b875">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="apple-mobile-web-app-title" content="HadYang">
<meta name="msapplication-tooltip" content="HadYang">
<meta name='msapplication-navbutton-color' content="#02b875">
<meta name="msapplication-TileColor" content="#02b875">
<meta name="msapplication-TileImage" content="/hadyang.github.io/icons/icon-144x144.png">
<link rel="icon" href="/hadyang.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/hadyang.github.io/icons/icon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/hadyang.github.io/icons/icon-32x32.png">
<link rel="icon" sizes="192x192" href="/hadyang.github.io/icons/icon-192x192.png">
<link rel="apple-touch-icon" href="/hadyang.github.io/icons/icon-152x152.png">
<link rel="manifest" href="/hadyang.github.io/manifest.json">


<link rel="preload" href="/hadyang.github.io/styles/main.min.css" as="style">

<link rel="preload" href="https://fonts.googleapis.com/css?family=Lobster" as="style">
<link rel="preload" href="/hadyang.github.io/images/avatar.png" as="image">
<link rel="preload" href="/hadyang.github.io/images/grey-prism.svg" as="image">


<style>
  body {
    background: rgb(244, 243, 241) url('/hadyang.github.io/images/grey-prism.svg') repeat fixed;
  }
</style>
<link rel="stylesheet" href="/hadyang.github.io/styles/main.min.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lobster">



<script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.2/dist/medium-zoom.min.js"></script>




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/video.js@7.3.0/dist/video-js.min.css">



  
  
<!--[if lte IE 8]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/videojs-ie8@1.1.2/dist/videojs-ie8.min.js"></script>
<![endif]-->

<!--[if lte IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/eligrey-classlist-js-polyfill@1.2.20180112/classList.min.js"></script>
<![endif]-->


</head>
  <body>
    
    <div class="suspension">
      <a role="button" aria-label="Go to top" title="Go to top" class="to-top is-hide"><span class="icon icon-up" aria-hidden="true"></span></a>
      
        
      
    </div>
    
    
  <header class="site-header">
  <img class="avatar" src="/hadyang.github.io/images/avatar.png" alt="Avatar">
  
  <h2 class="title">HadYang</h2>
  
  <p class="subtitle"></p>
  <button class="menu-toggle" type="button" aria-label="Main Menu" aria-expanded="false" tab-index="0">
    <span class="icon icon-menu" aria-hidden="true"></span>
  </button>

  <nav class="site-menu collapsed">
    <h2 class="offscreen">Main Menu</h2>
    <ul class="menu-list">
      
      
      
      
        <li class="menu-item
          
          
           is-active">
          <a href="hadyang.github.io/">Home</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="hadyang.github.io/tags/">Tags</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="hadyang.github.io/categories/">Categories</a>
        </li>
      
    </ul>
  </nav>
  <nav class="social-menu collapsed">
    <h2 class="offscreen">Social Networks</h2>
    <ul class="social-list"><li class="social-item">
          <a href="mailto:shihaoyang129@gmail.com" title="Email" aria-label="Email">
            <span class="icon icon-email" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="//github.com/hadyang" title="GitHub" aria-label="GitHub">
            <span class="icon icon-github" aria-hidden="true"></span>
          </a>
        </li></ul>
  </nav>
</header>

  <section class="main post-detail">
    <header class="post-header">
      <h1 class="post-title">事件分发过程</h1>
      <p class="post-meta">@ · Jun 4, 2016 · 5 min read</p>
    </header>
    <article class="post-content"><p>这篇文章我们继续分析Activity的事件分发过程。</p>

<ul>
<li>Step1 &ndash; ViewRootImpl.dispatchInputEvent</li>
</ul>

<pre><code class="language-Java">public void dispatchInputEvent(InputEvent event, InputEventReceiver receiver) {
        SomeArgs args = SomeArgs.obtain();
        args.arg1 = event;
        args.arg2 = receiver;
        Message msg = mHandler.obtainMessage(MSG_DISPATCH_INPUT_EVENT, args);
        msg.setAsynchronous(true);

        //Step2
        mHandler.sendMessage(msg);
    }
</code></pre>

<ul>
<li>Step2 &ndash; ViewRootImpl.doProcessInputEvents</li>
</ul>

<pre><code class="language-Java">void doProcessInputEvents() {
        // Deliver all pending input events in the queue.
        while (mPendingInputEventHead != null) {
            QueuedInputEvent q = mPendingInputEventHead;
            mPendingInputEventHead = q.mNext;
            if (mPendingInputEventHead == null) {
                mPendingInputEventTail = null;
            }
            q.mNext = null;

            ...
            //Step3
            deliverInputEvent(q);
        }
}
</code></pre>

<ul>
<li>Step3 &ndash; ViewRootImpl.deliverInputEvent</li>
</ul>

<pre><code class="language-Java">private void deliverInputEvent(QueuedInputEvent q) {
        ...

        if (stage != null) {
            //Step4
            stage.deliver(q);
        } else {
            finishInputEvent(q);
        }
}

</code></pre>

<ul>
<li>Step4 &ndash; ViewPostImeInputStage.onProcess</li>
</ul>

<p><code>stage.deliver(q)</code>最终调用到ViewPostImeInputStage.onProcess</p>

<pre><code class="language-Java">protected int onProcess(QueuedInputEvent q) {
        final int source = q.mEvent.getSource();
        if ((source &amp; InputDevice.SOURCE_CLASS_POINTER) != 0) {
        //Step5
        return processPointerEvent(q);
        } else if ((source &amp; InputDevice.SOURCE_CLASS_TRACKBALL) != 0) {
            return processTrackballEvent(q);
        } else {
            return processGenericMotionEvent(q);
        }
    }
</code></pre>

<ul>
<li>Step5 &ndash; ViewRootImpl.processPointerEvent</li>
</ul>

<pre><code class="language-Java">private int processPointerEvent(QueuedInputEvent q) {
      ...
      //Step6 mView为DecorView
      boolean handled = mView.dispatchPointerEvent(event);
      if (mAttachInfo.mUnbufferedDispatchRequested &amp;&amp; !mUnbufferedInputDispatch) {
          mUnbufferedInputDispatch = true;
      if (mConsumeBatchedInputScheduled) {
          scheduleConsumeBatchedInputImmediately();
        }
    }
    return handled ? FINISH_HANDLED : FORWARD;
}

</code></pre>

<ul>
<li>Step6 &ndash; View.dispatchPointerEvent</li>
</ul>

<pre><code class="language-Java">public final boolean dispatchPointerEvent(MotionEvent event) {
        if (event.isTouchEvent()) {
            return dispatchTouchEvent(event);
        } else {
            return dispatchGenericMotionEvent(event);
        }
    }
</code></pre>

<ul>
<li>Step6.1 &ndash; DecorView.dispatchTouchEvent</li>
</ul>

<pre><code class="language-Java">public boolean dispatchTouchEvent(MotionEvent ev) {
            final Callback cb = getCallback();
            //cb为Activity，Step7
            return cb != null &amp;&amp; !isDestroyed() &amp;&amp; mFeatureId &lt; 0 ? cb.dispatchTouchEvent(ev)
                    : super.dispatchTouchEvent(ev);
}
</code></pre>

<ul>
<li>Step7 &ndash; Activity.dispatchTouchEvent</li>
</ul>

<pre><code class="language-Java">public boolean dispatchTouchEvent(MotionEvent ev) {
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            onUserInteraction();
        }
        //Step8
        if (getWindow().superDispatchTouchEvent(ev)) {
            return true;
        }
        return onTouchEvent(ev);
    }
</code></pre>

<ul>
<li>Step8 &ndash; DecorView.superDispatchTouchEvent</li>
</ul>

<p>PhoneWindow.superDispatchTouchEvent(ev)最终调用DecorView.superDispatchTouchEvent</p>

<pre><code class="language-Java">public boolean superDispatchTouchEvent(MotionEvent event) {
            return super.dispatchTouchEvent(event);
}
</code></pre>

<ul>
<li>Step9 &ndash; ViewGroup.dispatchTouchEvent</li>
</ul>

<pre><code class="language-Java">public boolean dispatchTouchEvent(MotionEvent ev) {

        ...
        if (onFilterTouchEventForSecurity(ev)) {
            ...
            // Check for interception.
            //检查是否拦截该事件，只能拦截ACTION_DOWN
            final boolean intercepted;
            if (actionMasked == MotionEvent.ACTION_DOWN
                    || mFirstTouchTarget != null) {
                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;
                if (!disallowIntercept) {
                    intercepted = onInterceptTouchEvent(ev);
                    ev.setAction(action); // restore action in case it was changed
                } else {
                    intercepted = false;
                }
            } else {
                // There are no touch targets and this action is not an initial down
                // so this view group continues to intercept touches.
                intercepted = true;
            }

            // If intercepted, start normal event dispatch. Also if there is already
            // a view that is handling the gesture, do normal event dispatch.
            if (intercepted || mFirstTouchTarget != null) {
                ev.setTargetAccessibilityFocus(false);
            }

            // Check for cancelation.
            final boolean canceled = resetCancelNextUpFlag(this)
                    || actionMasked == MotionEvent.ACTION_CANCEL;

            // Update list of touch targets for pointer down, if needed.
            final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;
            TouchTarget newTouchTarget = null;
            boolean alreadyDispatchedToNewTouchTarget = false;
            if (!canceled &amp;&amp; !intercepted) {

                View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()
                        ? findChildWithAccessibilityFocus() : null;

                if (actionMasked == MotionEvent.ACTION_DOWN
                        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                    final int actionIndex = ev.getActionIndex(); // always 0 for down
                    final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)
                            : TouchTarget.ALL_POINTER_IDS;

                    final int childrenCount = mChildrenCount;
                    if (newTouchTarget == null &amp;&amp; childrenCount != 0){
                        final View[] children = mChildren;
                        for (int i = childrenCount - 1; i &gt;= 0; i--) {
                            final int childIndex = customOrder
                                    ? getChildDrawingOrder(childrenCount, i) : i;
                            final View child = (preorderedList == null)
                                    ? children[childIndex] : preorderedList.get(childIndex);
                            ...

                            //事件分发 Step10
                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                                // Child wants to receive touch within its bounds.
                                mLastTouchDownTime = ev.getDownTime();
                                if (preorderedList != null) {
                                    // childIndex points into presorted list, find original index
                                    for (int j = 0; j &lt; childrenCount; j++) {
                                        if (children[childIndex] == mChildren[j]) {
                                            mLastTouchDownIndex = j;
                                            break;
                                        }
                                    }
                                } else {
                                    mLastTouchDownIndex = childIndex;
                                }
                                mLastTouchDownX = ev.getX();
                                mLastTouchDownY = ev.getY();

                                //添加下一个子View
                                newTouchTarget = addTouchTarget(child, idBitsToAssign);
                                alreadyDispatchedToNewTouchTarget = true;
                                break;
                            }

                            // The accessibility focus didn't handle the event, so clear
                            // the flag and do a normal dispatch to all children.
                            ev.setTargetAccessibilityFocus(false);
                        }
                        if (preorderedList != null) preorderedList.clear();
                    }
                    ...
                }
            }

            // Dispatch to touch targets.
            //如果ViewGroup拦截了这个事件，mFirstTouchTarget则为NULL，即进入这个分支，调用自己的dispatchTouchEvent
            if (mFirstTouchTarget == null) {
                // No touch targets so treat this as an ordinary view.
                handled = dispatchTransformedTouchEvent(ev, canceled, null,
                        TouchTarget.ALL_POINTER_IDS);
            }
        return handled;
}
</code></pre>

<ul>
<li>Step10 &ndash; ViewGroup.dispatchTransformedTouchEvent</li>
</ul>

<pre><code class="language-Java">private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
            View child, int desiredPointerIdBits) {
        final boolean handled;

        // Canceling motions is a special case.  We don't need to perform any transformations
        // or filtering.  The important part is the action, not the contents.
        final int oldAction = event.getAction();
        if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {
            event.setAction(MotionEvent.ACTION_CANCEL);
            if (child == null) {
                //自己进行事件分发
                handled = super.dispatchTouchEvent(event);
            } else {
                //对子View进行事件分发
                //Step11
                handled = child.dispatchTouchEvent(event);
            }
            event.setAction(oldAction);
            return handled;
        }
}
</code></pre>

<ul>
<li>Step11 &ndash; View.dispatchTouchEvent</li>
</ul>

<pre><code class="language-Java">public boolean dispatchTouchEvent(MotionEvent event) {
        boolean result = false;

        if (onFilterTouchEventForSecurity(event)) {
            //noinspection SimplifiableIfStatement
            ListenerInfo li = mListenerInfo;
            if (li != null &amp;&amp; li.mOnTouchListener != null
                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED
                    //onTouch方法比onTouchEvent方法优先级高，如果onTouch返回为true，即result==true，则不走onTouchEvent
                    &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {
                result = true;
            }

            //Step12
            if (!result &amp;&amp; onTouchEvent(event)) {
                result = true;
            }
        }

        return result;
}
</code></pre>

<ul>
<li>Step12 &ndash; View.onTouchEvent</li>
</ul>

<pre><code class="language-Java">public boolean onTouchEvent(MotionEvent event) {
        //View不可见，还是会消耗事件
        if ((viewFlags &amp; ENABLED_MASK) == DISABLED) {
            if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) {
                setPressed(false);
            }
            // A disabled view that is clickable still consumes the touch
            // events, it just doesn't respond to them.
            return (((viewFlags &amp; CLICKABLE) == CLICKABLE
                    || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)
                    || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);
        }

        //如果设置的有代理，则会执行代理
        if (mTouchDelegate != null) {
            if (mTouchDelegate.onTouchEvent(event)) {
                return true;
            }
        }

        if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||
                (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||
                (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) {
            switch (action) {
                case MotionEvent.ACTION_UP:
                    boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;
                    if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) {

                        ...
                            if (!focusTaken) {
                                if (mPerformClick == null) {
                                    mPerformClick = new PerformClick();
                                }
                                //如果onClickListener不为空，执行onClick
                                if (!post(mPerformClick)) {
                                    performClick();
                                }
                            }
                        }

                        ...
                    break;
                case MotionEvent.ACTION_DOWN:
                    if (isInScrollingContainer) {
                        ...
                    } else {
                        // Not inside a scrolling container, so show the feedback right away
                        setPressed(true, x, y);
                        //如果onLongClickListener不为空，则执行onLongClick
                        checkForLongClick(0);
                    }
                    break;
                    ...
            }
            return true;
        }
        return false;
}
</code></pre></article>
    <footer class="post-footer">
      
      <ul class="post-tags">
        
          <li><a href="/tags/%E6%BA%90%E7%A0%81"><span class="tag">源码</span></a></li>
        
      </ul>
      
      <p class="post-copyright">
        This post was published <strong>1009</strong> days ago, content in the post may be inaccurate, even wrong now, please take risk yourself.
      </p>
    </footer>
    
      
    
  </section>
  
<footer class="site-footer">
  <p>© 2017-2019 HadYang</p>
  <p>Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> with theme <a href="https://github.com/laozhu/hugo-nuo" target="_blank" rel="noopener">Nuo</a>.</p>
  
</footer>


<script src="https://cdn.jsdelivr.net/npm/smooth-scroll@15.0.0/dist/smooth-scroll.min.js"></script>



<script async src="https://cdn.jsdelivr.net/npm/video.js@7.3.0/dist/video.min.js"></script>




<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      displayMath: [['$$','$$'], ['\\[','\\]']],
      processEscapes: true,
      processEnvironments: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      TeX: { equationNumbers: { autoNumber: "AMS" },
      extensions: ["AMSmath.js", "AMSsymbols.js"] }
    },
  });
</script>
<script type="text/x-mathjax-config">
  // Fix <code> tags after MathJax finishes running. This is a
  // hack to overcome a shortcoming of Markdown. Discussion at
  // https://github.com/mojombo/jekyll/issues/199
  MathJax.Hub.Queue(() => {
    MathJax.Hub.getAllJax().map(v => v.SourceElement().parentNode.className += ' has-jax');
  });
</script>



<script src="/hadyang.github.io/scripts/index.min.js"></script>

<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('\/hadyang.github.io\/service-worker.js').then(function() {
      console.log('[ServiceWorker] Registered');
    });
  }
</script>








  </body>
</html>
