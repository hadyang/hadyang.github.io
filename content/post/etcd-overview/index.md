---
title: 什么是 ETCD？
draft: true
categories: 
    - 深入理解ETCD
---

## ETCD

ETCD 提供强一致性的分布式 K-V 存储，客户端通过 HTTP/HTTPS 协议与其进行交互。ETCD 存储结构类似与文件系统，数据存储在分层组织的目录中。同时，ETCD 也提供 Watch 能力，当某个 Key 变化时发出通知。

在实现上，ETCD 采用有强大的跨平台能力和高性能的 Go 语言编写，底层节点采用 Raft 共识算法进行通信。由于 Raft 算法中，从节点不接受用户请求，所以 ETCD 中主节点的吞吐量是很重要的指标。同时，由于 Raft 算法需要与集群中大部分节点进行通信，集群节点之间的网络延迟会极大的影响 ETCD 的整体性能。


## 基本接口

put

get foo foo4


## 存储结构

ETCD 是被设计用来存储低频更新的数据，并且提供可靠的查询。ETCD 

持久化、多版本、并发控制的数据模型

ectd 存储多版本的持久化 kv 数据，当 kv 写入新值时，etcd 会将旧值进行持久化存储。kv 存储是不可变的，更新操作都不会进行替换更新，而是生成新版本的数据。所有老版本的 key 依然是能可访问 和 watch 的。为了防止数据无限制的增长，存储会压缩老版本的数据。


### 逻辑视图

逻辑层来看整个存储是 无层级结构的 key 空间，key 空间的字符串按字典序排序，所以可以高效的支持范围查询

key 空间保留多修订，当存储被创建时，初始化修订为1。每次原子更新（事务可能包含多个操作）会在 key 空间创建一个新的 “修订”。 所有之前的 修订 都不会改变。key 的老版本数据可以通过之前的修订获取。同样的，修订也可以被索引，范围 watch 修订是有效的。如果存储压缩到 存储空间，压缩修订之前的压缩都会被移除。在整个集群的生命周期中，修订是单调递增的。


从 key 的创建到删除，可能跨越很多 世代，每个 key 可能会有一个或多个世代。创建 key 会递增 key 的版本，如果 key 在当前 修订 中不存在，那么版本号从 1开始。删除一个 key 会进行逻辑删除，通过将 key 的当前世代版本置为0。每次 key 的修改都会增加其版本号，所以版本号在 key 的世代中是单调递增的。 当压缩发生时，在被压缩的修订之前的世代都会被移除，并且会将压缩修订之前的置移除（最新的除外）


修订：

世代：

版本：

key 的版本 与 修订的版本


### 物理结构

MVCC

etcd 将 kv 存储在持久化的 b+ 树中，存储中每个的修订 只包含与前一个修订的差异数据。单个 修订 可能对应树中多个 key

kv 中的 key 是一个（major，sub，type）三元组，major 表示存储中当前持有这个 key 的修订，sub 用来区分在同一个修订中的多个key，type 是对特殊 value 可选的后缀（比如 t 如果 数据被逻辑删除）。value 中包含从前一个修订的修改，因此与前一个修订相比 有一个增量。b+ 树是按照 key 的字典序排列的。通过修订增量进行范围查询很快，这样就能快速的找到修订与修订之间的修改。压缩会移除过期的 kv

ectd 还会在内存中保存一个 b 树来加速范围查询。b 树中的 key 是存储暴露给用户的key，value 直接指向持久化的 b+ 树。压缩会移除已过期的指针



## 功能特性


## 使用场景


## 性能对比

https://github.com/etcd-io/etcd/blob/master/Documentation/op-guide/performance.md#benchmarks


## 权限控制


## 运行时重配置